---
layout: '../../layouts/MarkdownPost.astro'
title: '数组学习更多知识补充'
pubDate: 2023-04-26
description: '今日第一天整理迁移：'
author: 'henry'
cover:
    url: 'https://cdn2.unrealengine.com/vr-week-2023-header-4-1920x1080-376e6c48383f.jpg?resize=1&w=1920'
    square: 'https://cdn2.unrealengine.com/vr-week-2023-header-4-1920x1080-376e6c48383f.jpg?resize=1&w=1920'
    alt: 'cover'
tags:
  [
    "数组",
  ]
theme: 'dark'
featured: true
---

## 您将收获
- JS 中 0.1 + 0.2 !== 0.3 的原因
- IEEE754 标准、浮点数
- 计算机存储和计算浮点数的原理

### IEEE754

JavaScript 中只有一种数字相关类型 – Number ,并使用双精度浮点数存储，以 64 位固定长度来表示，相当于标准的  double  双精度浮点数

二进制浮点数算术标准 IEEE 中的存储格式为：

```
V = (-1)^S × M × 2^E
复制代码
(-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。

M表示有效数字，尾数位，大于等于1，小于2。

2^E表示指数位。

举例说明

十进制下
5.0 = 5 * 10^(0)

二进制下
5.0 = 101.0 = 1.01 * 2^(2)
        --> (-1)^0 * 1.01 * 2^(2)
        --> S = 0, M = 1.01, E = 2


```

### 存储格式

> 对于单精度浮点数即32位的浮点数，最高的1位是符号位 S ，接着的8位是指数 E ，剩下的23位为有效数字 M。

> 对于双精度的浮点数即64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。

// 这一步就是造成 JS 中 0.1 + 0.2 !== 0.3 的原因.

十进制转换二进制：要点：除二取余，倒序排列
但是0.1和0.2转成二进制后，都是除不尽。
~~~
   0  01111111100   1100110011001100110011001100110011001100110011001101
+  0  01111111100   1001100110011001100110011001100110011001100110011010
-------------------------------------------------------------------
=  0  01111111100  10110011001100110011001100110011001100110011001100111


2^-2 + (1+(1*2^-1 + 0 * 2^-2+1*2^-3+1*2^-4+... )
=
0.3000000000000000444089209850062616169452667236328125
由于精度问题：只取到 0.30000000000000004(这一步是我们看到最终计算结果)


~~~


### Number最大的数字是16位数：正负：9007199254740991
所以一般超过16位，使用字符串返回。
