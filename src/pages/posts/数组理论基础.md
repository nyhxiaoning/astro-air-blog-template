---
layout: "../../layouts/MarkdownPost.astro"
title: "leetcode-数组理论基础-js"
pubDate: 2023-04-26
description: "数组理论基础"
author: "henry"
cover:
    url: 'https://cdn2.unrealengine.com/vr-week-2023-header-4-1920x1080-376e6c48383f.jpg?resize=1&w=1920'
    square: 'https://cdn2.unrealengine.com/vr-week-2023-header-4-1920x1080-376e6c48383f.jpg?resize=1&w=1920'
    alt: 'cover'
tags: ["数组"]
theme: "dark"
featured: false
---




## 数组的特点

> 需要两点注意的是

- **数组下标都是从 0 开始的。**
- **数组内存空间的地址是连续的**

正是**因为数组的在内存空间的地址是连续的，所以我们在删除或者增添元素的时候，就难免要移动其他元素的地址。**

> js 中的一般来说，Array 是一种结构类型，它表示在内存中连续分配的数据块（数字、对象等）。而 Set 是一个集合，一种抽象数据类型，只包含不同的元素/对象，不需要按索引顺序分配。

JS数组有点“特殊”.同一个JS数组的元素可以是不同的数据类型，那我们肯定没法固定长度为每个元素分配空间。



## 数组的优势和劣势:读操作多、写操作少

数组的优势和劣势

> 优势： 数组拥有非常高效的随机访问能力，只要给出下标，就可以用常量时间找到对应元素。有一种高效查找元素的算法叫作二分查找， 就是利用了数组的这个优势。

> 劣势： 数组的劣势体现在插入和删除元素方面。由于数组元素连续紧密地存储在内存中，插入、删除元素都会导致大量元素被迫移动，影响效率。

> 总结： 数组所适合的是读操作多、写操作少的场景！
> js 中的数组并不完全符合数据结构中的数组定义，js 中数组的可以是不同的数据类型，也可以是非线性循序。

### 为什么js中数组特殊?看看下面的V8 中的快慢属性

在 V8 源码中清晰地表明，JSArray 继承自 JSObject，即数组是一个特殊的对象，而 JS 中所有非原始类型都是对象的实例，所以 JS 中数组可以存储多种类型的值。

数组内部也是用key-value的存储形式


## 3.深入 V8 - js 数组的内存是如何分配的

### 核心案例：为什么会这样？js数组有什么不同

```
let arr = new Array(100).fill(1)
arr[0] = 1000
arr[1] = 0.001 // 这一行代码居然会让arr占用的内存翻一倍

arr[1] = 1 // 这样并无法挽回增加的一倍内存

arr[1] = "1" // 但是这样却会让arr的内存变为原来的大小

```

### V8 中的快慢属性

> 快慢转换总结
- 快数组（FixedArray）就是以空间换时间的方式，申请了大块连续内存，提高了执行效率。
- 慢数组以时间换空间，不必申请连续的空间，节省了内存，但需要付出效率变差的代价。
- 数组元素少的时候是线性结构存储：快数组（FixedArray）的，内存地址连续，查找速度快，可以动态扩缩容；查找很快，使用数组下标元素。

- 数组元素多的时候转化为慢数组，通过创建了一个字典来记录映射关系，内存不连续，通过大名鼎鼎的Object.defineProperty(object, key, descriptor)创建
- js的数组看似不同，其实只是V8 在底层实现上做了一层封装，使用两种数据结构实现数组，并且通过时间和空间2个纬度的取舍，优化了数组的性能。

### for-in遍历打印对象属性为什么不连续？
对于整数型的 key 值，会从小到大遍历，对于非整数型的 key 值，会按照设置的先后顺序遍历。
~~~
function Foo() {
  this[100] = 'test-100'
  this[1] = 'test-1'
  this["B"] = 'foo-B'
  this[50] = 'test-50'
  this[9] = 'test-9'
  this[8] = 'test-8'
  this[3] = 'test-3'
  this[5] = 'test-5'
  this["A"] = 'foo-A'
  this["C"] = 'foo-C'
}

const foo = new Foo()

for (const key in foo) {
  console.log(`key:${key}, value:${foo[key]}`)
}
// key:1, value:test-1
// key:3, value:test-3
// key:5, value:test-5
// key:8, value:test-8
// key:9, value:test-9
// key:50, value:test-50
// key:100, value:test-100
// key:B, value:foo-B
// key:A, value:foo-A
// key:C, value:foo-C

~~~

> 细心一点观察可以发现，对于整数型的 key 值，会从小到大遍历，对于非整数型的 key 值，会按照设置的先后顺序遍历。在 V8 中，前后者分别被称为 数组索引属性（Array-indexed Properties）和 命名属性（Named Properties），遍历时一般会先遍历前者。前后两者在底层存储在两个单独的数据结构中，分别用 elements 和 properties 两个指针指向它们

补充：V8 有一种策略：如果命名属性少于等于 10 个时，命名属性会直接存储到对象本身，而无需先通过 properties 指针查询，再获取对应 key 的值，省去中间的一步，从而提升了查找属性的效率。直接存储到对象本身的属性被称为 对象内属性（In-object Properties）。对象内属性与 properties、elements 处于同一层级。

### 快数组和慢数组
~~~
const LIMIT = 6 * 1024 * 1024;
let arr = new Array(LIMIT); // 快数组
arr[arr.length+1026] = 1; // 快数组转为慢数组

~~~

在行 2 声明完毕后 arr 是一个空数组，但在行 3 马上又定义索引 arr.length+1026 处值为 1，此时如果为 arr 创建一个长度为 arr.length+1026+1 的数组连续内存来存储这样的稀疏数据将会非常占用内存，为了应对这种情况，V8 会将数组降级为慢数组，创建一个字典来存储「键、值、描述符」（key、value、descriptor） 三元组。当使用 Object.defineProperty 自定义 key、value、descriptor 时，V8 都会使用慢属性，对应到数组中就是慢数组。

> 快慢数组转换：如果快数组新增的索引与原来最大索引的差值大于 1024，快数组会被转换会慢数组
> 当慢数组转换成快数组能节省不少于 50%  的空间时，才会将其转换。


### V8对数字的分类

0.2+0.1为什么不等于0.3?

js中是64位来表示数字，那么在V8引擎层面是否也是使用64位来表示数字呢？

因为我们知道，数字在内存中的表示可以有多种（如下），而64位，显然是最慢的
~~~
representation	bits
8位二进制补码	0010 1001
32位二进制补码	0000 0000 0000 0000 0000 0000 0010 1010
二进制编码的十进数码	0100 0010
32位 IEEE-754 单精度浮点	0100 0010 0010 1000 0000 0000 0000 0000
64位 IEEE-754 双精度浮点	0100 0000 0100 0101 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000
~~~

> ECMAScript 标准约定number数字需要被当成 64 位双精度浮点数处理，但事实上，一直使用 64 位去存储任何数字实际是非常低效的，所以 JavaScript 引擎并不总会使用 64 位去存储数字，引擎在内部采用其他内存表示方式（如 32 位），只要保证数字外部所有能被监测到的特性对齐 64 位的表现就行。

#### V8中的Smi和HeapNumber

注意：这个仅仅是引擎层面的处理，js内部只认识数字，不区分整数和浮点数
可以从上面看出，Smi代表的是小整数,而HeapNumber则代表了一些浮点数以及无法用32位表示的数，比如NaN,Infinity,-0




